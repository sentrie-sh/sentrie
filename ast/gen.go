//go:build generate
// +build generate

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/sentrie-sh/sentrie/constraints"
)

//go:generate go run gen.go

// This generator collects the typeref constraints from the constraints package and generates the corresponding maps in the ast package.
// This is used to validate the constraints of the typerefs at parse time.
func main() {
	// Collect name->numArgs maps from canonical definitions in constraints package
	sections := []struct {
		varName string
		source  map[string]any
	}{
		{"genNumberConstraints", toAnyMap(constraints.NumberContraintCheckers)},
		{"genStringConstraints", toAnyMap(constraints.StringContraintCheckers)},
		{"genBoolConstraints", toAnyMap(constraints.BoolConstraintCheckers)},
		{"genListConstraints", toAnyMap(constraints.ListContraintCheckers)},
		{"genMapConstraints", toAnyMap(constraints.MapContraintCheckers)},
		{"genDocumentConstraints", toAnyMap(constraints.DocumentContraintCheckers)},
		{"genRecordConstraints", toAnyMap(constraints.RecordContraintCheckers)},
		{"genShapeConstraints", toAnyMap(constraints.ShapeContraintCheckers)},
	}

	var buf bytes.Buffer

	var content = []string{
		"// Code generated by go generate; DO NOT EDIT.",
		"// This file is generated from canonical definitions in `constraints` package.",
		"//",
		"// To update definitions, update the `constraints` package and run `go generate`.",
		"//",
	}

	buf.WriteString(strings.Join(content, "\n"))
	buf.WriteString("\n\n")
	buf.WriteString("package ast\n\n")

	for _, sec := range sections {
		writeMap(&buf, sec.varName, sec.source)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	outPath := filepath.Join(".", "typeref_constraint_args_gen.go")
	if err := os.WriteFile(outPath, formatted, 0644); err != nil {
		panic(err)
	}
}

// toAnyMap converts a typed map[name]ConstraintDefinition[T] to a generic map[name]any with NumArgs extracted.
func toAnyMap[T any](src map[string]constraints.ConstraintDefinition[T]) map[string]any {
	res := make(map[string]any, len(src))
	for name, def := range src {
		res[name] = def.NumArgs
	}
	return res
}

func writeMap(buf *bytes.Buffer, varName string, src map[string]any) {
	// Stable order for reproducible diffs
	keys := make([]string, 0, len(src))
	for k := range src {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	buf.WriteString(fmt.Sprintf("var %s = map[string]int{\n", varName))
	for _, k := range keys {
		v := src[k]
		buf.WriteString(strconvQuote(k))
		buf.WriteString(": ")
		buf.WriteString(fmt.Sprintf("%d", v.(int)))
		buf.WriteString(",\n")
	}
	buf.WriteString("\t}\n\n")
}

func strconvQuote(s string) string {
	// minimal quoting for Go string literal
	return "\"" + strings.ReplaceAll(s, "\"", "\\\"") + "\""
}
