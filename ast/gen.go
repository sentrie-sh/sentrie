// SPDX-License-Identifier: Apache-2.0
//
// Copyright 2025 Binaek Sarkar
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build generate
// +build generate

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/sentrie-sh/sentrie/constraints"
)

//go:generate go run gen.go

// This generator collects the typeref constraints from the constraints package and generates the corresponding maps in the ast package.
// This is used to validate the constraints of the typerefs at parse time.
func main() {
	// Collect name->numArgs maps from canonical definitions in constraints package
	sections := []struct {
		varName string
		source  map[string]any
	}{
		{"genNumberConstraints", toAnyMap(constraints.NumberContraintCheckers)},
		{"genStringConstraints", toAnyMap(constraints.StringContraintCheckers)},
		{"genTrinaryConstraints", toAnyMap(constraints.TrinaryConstraintCheckers)},
		{"genListConstraints", toAnyMap(constraints.ListContraintCheckers)},
		{"genMapConstraints", toAnyMap(constraints.MapContraintCheckers)},
		{"genDocumentConstraints", toAnyMap(constraints.DocumentContraintCheckers)},
		{"genRecordConstraints", toAnyMap(constraints.RecordContraintCheckers)},
		{"genShapeConstraints", toAnyMap(constraints.ShapeContraintCheckers)},
	}

	var buf bytes.Buffer

	var content = []string{
		"// Copyright 2025 Binaek Sarkar",
		"//",
		"// Licensed under the Apache License, Version 2.0 (the \"License\");",
		"// you may not use this file except in compliance with the License.",
		"// You may obtain a copy of the License at",
		"//",
		"//	http://www.apache.org/licenses/LICENSE-2.0",
		"//",
		"// Unless required by applicable law or agreed to in writing, software",
		"// distributed under the License is distributed on an \"AS IS\" BASIS,",
		"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
		"// See the License for the specific language governing permissions and",
		"// limitations under the License.",
		"//",
		"// Code generated by go generate; DO NOT EDIT.",
		"// This file is generated from canonical definitions in `constraints` package.",
		"//",
		"// To update definitions, update the `constraints` package and run `go generate`.",
	}

	buf.WriteString(strings.Join(content, "\n"))
	buf.WriteString("\n\n")
	buf.WriteString("package ast\n\n")

	for _, sec := range sections {
		writeMap(&buf, sec.varName, sec.source)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	outPath := filepath.Join(".", "typeref_constraint_args_gen.go")
	if err := os.WriteFile(outPath, formatted, 0644); err != nil {
		panic(err)
	}
}

// toAnyMap converts a typed map[name]ConstraintDefinition[T] to a generic map[name]any with NumArgs extracted.
func toAnyMap[T any](src map[string]constraints.ConstraintDefinition[T]) map[string]any {
	res := make(map[string]any, len(src))
	for name, def := range src {
		res[name] = def.NumArgs
	}
	return res
}

func writeMap(buf *bytes.Buffer, varName string, src map[string]any) {
	// Stable order for reproducible diffs
	keys := make([]string, 0, len(src))
	for k := range src {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	buf.WriteString(fmt.Sprintf("var %s = map[string]int{\n", varName))
	for _, k := range keys {
		v := src[k]
		buf.WriteString(strconvQuote(k))
		buf.WriteString(": ")
		buf.WriteString(fmt.Sprintf("%d", v.(int)))
		buf.WriteString(",\n")
	}
	buf.WriteString("\t}\n\n")
}

func strconvQuote(s string) string {
	// minimal quoting for Go string literal
	return "\"" + strings.ReplaceAll(s, "\"", "\\\"") + "\""
}
